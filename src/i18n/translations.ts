export const translations = {
  en: {
    visualizations: 'Algorithm Visualizations',
    contents: 'Contents',
    egyptianMultiplication: 'Section 2.1 - Egyptian Multiplication (Russian Multiplication)', 
    sieveOfEratosthenes: 'Section 3.2-3.3 - Sieve of Eratosthenes',
    primeCounting: 'Exercise 3.3 - Prime Counting Function',
    palindromicPrimes: 'Exercise 3.4 - Palindromic Primes',
    euclideanGcm: 'Section 4.2 - Euclidean Algorithm (GCM/GCD)',
    primeChecker: 'Section 5.1 - Prime Number Checker',
    fibonacci: 'Exercise 7.1 - How Many Additions Does the Basic Fibonacci Algorithm Need? (Time Complexity: O(φⁿ))',
    fastFibonacci: 'Section 7.7 - Calculate nth Fibonacci Number Using Power Algorithm (Time Complexity: O(log n))',
    shortestPath: 'Section 8.6 - Finding Shortest Distance Between Any Two Nodes in a Directed Graph',
    piUpperBound: 'Exercise 9.2 - Finding an Upper Bound for π Through Visual Proof',
    rotateAlgorithm: 'Section 11.3 - Demonstration of Sequence Rotation Algorithm',
    gcdComparison: 'Exercise 12.1 - Performance Comparison of Stein and Euclidean GCD Algorithms',
    rsaAlgorithm: 'Section 13.4 - RSA Algorithm',
    backToHome: 'Back to Home',
    title: 'Egyptian Multiplication (Russian Multiplication)',
    sieveTitle: 'Sieve of Eratosthenes',
    primeCountingTitle: 'Prime Counting Function',
    palindromicPrimesTitle: 'Palindromic Primes',
    gcmTitle: 'Euclidean Algorithm (GCM/GCD)',
    primeCheckerTitle: 'Prime Number Checker',
    fibonacciTitle: 'Basic Fibonacci Algorithm',
    fastFibonacciTitle: 'Fast Fibonacci Calculator',
    shortestPathTitle: 'Finding Shortest Distance Using Matrix Power',
    piUpperBoundTitle: 'Visual Proof of π\'s Upper Bound',
    rotateTitle: 'Sequence Rotation Algorithm',
    gcdComparisonTitle: 'GCD Algorithm Performance Comparison',
    rsaTitle: 'RSA Public Key Cryptography',
    description: 'An ancient method of multiplication using doubling and addition',
    sieveDescription: 'An ancient algorithm for finding all prime numbers up to a given limit',
    primeCountingDescription: 'Visualization of π(n) and its approximation by n/ln(n)',
    palindromicPrimesDescription: 'Find palindromic prime numbers in different bases',
    gcmDescription: 'Calculate the Greatest Common Measure (GCM/GCD) of two numbers using the Euclidean algorithm',
    primeCheckerDescription: 'Check if a number is prime and get its prime factorization',
    fibonacciDescription: 'Calculate Fibonacci numbers and count additions using the basic recursive algorithm',
    fastFibonacciDescription: 'Calculate Fibonacci numbers using matrix exponentiation',
    shortestPathDescription: 'Find shortest paths in a directed graph using matrix power algorithm in the tropical semiring',
    piUpperBoundDescription: 'Visualize how inscribed regular polygons can help us find an upper bound for π',
    rotateDescription: 'Visualize how rotation can be implemented by swapping two subsequences',
    rotateExplanation: 'Rotation is equivalent to decomposing the entire range into two subranges and then swapping them. For example, rotating [0,1,2,3,4,5,6] by 5 steps is equivalent to swapping [0,1] with [2,3,4,5,6], resulting in [2,3,4,5,6,0,1].',
    gcdComparisonDescription: 'Compare the performance of Stein\'s and Euclidean algorithms for computing GCD',
    rsaDescription: 'Demonstration of RSA encryption and decryption with step-by-step visualization',
    range: 'Range',
    calculate: 'Calculate',
    reset: 'Reset',
    running: 'Running performance test...',
    results: 'Results',
    steinAlgorithm: 'Stein\'s Algorithm',
    euclideanAlgorithm: 'Euclidean Algorithm',
    totalTime: 'Total Time',
    milliseconds: 'ms',
    testSize: '90,000 pairs of random numbers',
    complete: 'complete',
    language: '中文',
    firstNumber: 'First Number',
    secondNumber: 'Second Number',
    required: '(Required)',
    inputRequired: 'Both numbers are required',
    steps: 'Steps',
    powers: 'Powers of 2',
    doubling: 'Doubling',
    selected: 'Selected',
    result: 'Result',
    maxNumber: 'Maximum Number',
    base: 'Base',
    sieveInputDescription: 'Enter a number to find all prime numbers up to that value',
    sieveInputRequired: 'Please enter a number between 2 and 9999',
    iteration: 'Next Iteration',
    generate: 'Generate',
    allPrimesFound: 'All prime numbers have been found! The numbers with green background are prime numbers.',
    recursiveStep: 'Next Step',
    startCalculation: 'Start Calculation',
    currentValues: 'Current Values',
    aValue: 'a = ',
    bValue: 'b = ',
    remainderValue: 'remainder = ',
    gcmResult: 'GCM/GCD = ',
    check: 'Check',
    enterNumber: 'Enter a number',
    numberPlaceholder: 'Enter a number to check',
    isPrime: 'is prime!',
    isNotPrime: 'is not prime.',
    isMersennePrime: 'is a Mersenne prime! (2^{0} - 1)',
    mersenneLink: 'Visit GIMPS (Great Internet Mersenne Prime Search)',
    inputTooLarge: 'Input is too large. Please enter a smaller number.',
    fastFibonacciInput: 'Enter a number (0-5000)',
    fastFibonacciResult: 'The nth Fibonacci number is:',
    fastFibonacciOperations: 'Operation Counts',
    additions: 'Additions:',
    subtractions: 'Subtractions:',
    multiplications: 'Multiplications:',
    fastFibonacciTooLarge: 'Please enter a number between 0 and 5000',
    powerStep: 'Matrix power {0}',
    initialMatrix: 'Initial adjacency matrix',
    nextPower: 'Next Power',
    calculationComplete: 'Calculation complete! The matrix shows the shortest distances between all pairs of nodes.',
    shortestPathExplanation: 'The matrix shows the shortest path distances between nodes. ∞ means there is no path between those nodes.',
    fibonacciInput: 'Enter a number (0-40)',
    fibonacciResult: 'The {n}th Fibonacci number is:',
    additionCount: 'Number of additions performed:',
    fibonacciExplanation: 'The basic recursive algorithm performs many redundant calculations, leading to an exponential number of additions. This is why we limit input to 40 to prevent excessive computation time.',
    fibonacciTimeComplexity: 'Time Complexity: O(φⁿ), where φ ≈ 1.618 is the golden ratio',
    generateKeys: 'Generate Key Pair',
    keyDetails: 'Key Details',
    publicExponent: 'public exponent',
    privateExponent: 'private exponent',
    rsaKeysNote: 'Note: For demonstration purposes, we use small prime numbers. In practice, much larger primes (2048+ bits) are used.',
    messageToEncrypt: 'Message to Encrypt',
    enterMessage: 'Enter your message here',
    encrypt: 'Encrypt',
    decrypt: 'Decrypt',
    encryptedMessage: 'Encrypted Message',
    decryptedMessage: 'Decrypted Message',
    publicKey: 'Public Key (e, n)',
    privateKey: 'Private Key (d, n)',
    publicKeyFormat: 'Public Key Format: (e, n)',
    privateKeyFormat: 'Private Key Format: (d, n)',
    rsaSteps: 'RSA Steps',
    rsaStep1: '1. Key Generation',
    rsaStep2: '2. Encryption',
    rsaStep3: '3. Decryption',
    rsaPrimes: 'Random Primes',
    rsaModulus: 'Modulus',
    rsaTotient: 'Totient',
    rsaEncryptionFormula: 'Encryption Formula',
    rsaDecryptionFormula: 'Decryption Formula',
    rsaFormulaExplanation: 'For each byte m in the message:',
    rsaEncryptionFormulaDetail: 'c = m^e mod n',
    rsaDecryptionFormulaDetail: 'm = c^d mod n',
    rsaDataFlow: 'Data Flow',
    rsaOriginalBytes: 'Original Bytes',
    rsaEncryptedValues: 'Encrypted Values',
    rsaDecryptedBytes: 'Decrypted Bytes',
    rsaShowSteps: 'Show Steps',
    rsaHideSteps: 'Hide Steps',
    rsaStep1Explanation: 'Two random prime numbers p and q are chosen, and their product n becomes the modulus. The totient φ(n) = (p-1)(q-1) is calculated.',
    rsaStep2Explanation: 'The message is converted to bytes and each byte is encrypted using the public key (e, n).',
    rsaStep3Explanation: 'Each encrypted value is decrypted using the private key (d, n) to recover the original bytes.'
  },
  zh: {
    visualizations: '算法可视化',
    contents: '目录',
    egyptianMultiplication: '2.1节 - 埃及乘法(俄式乘法)', 
    sieveOfEratosthenes: '3.2节-3.3节 - 埃拉托色尼筛法',
    primeCounting: '习题3.3 - 素数计数函数 (计算较慢，请耐心等待)',
    palindromicPrimes: '习题3.4 - 回文素数',
    euclideanGcm: '4.2节 - 欧几里得算法(GCM/GCD)',
    primeChecker: '5.1节 - 判断一个数是否为素数',
    fibonacci: '习题7.1 - 最初级的斐波那契数列算法需要执行多少次加法（时间复杂度:O(φⁿ)）',
    fastFibonacci: '7.7节 - 使用幂算法计算第n个斐波那契数（时间复杂度:O(log⁡n)）',
    shortestPath: '8.6节 - 找出有向图中任意两个节点之间的最短距离',
    piUpperBound: '习题9.2 - 通过可视化证明来找出π的一个上限',
    rotateAlgorithm: '11.3节 - 演示序列的"旋转"算法',
    gcdComparison: '习题12.1 - 对比用斯坦因算法和欧几里得算法计算GCD的性能',
    rsaAlgorithm: '13.4节 - RSA算法',
    backToHome: '返回主页',
    title: '埃及乘法(俄式乘法)',
    sieveTitle: '埃拉托色尼筛法',
    primeCountingTitle: '素数计数函数',
    palindromicPrimesTitle: '回文素数',
    gcmTitle: '欧几里得算法(GCM/GCD)',
    primeCheckerTitle: '素数判定',
    fibonacciTitle: '最初级的斐波那契数列算法',
    fastFibonacciTitle: '快速斐波那契数计算器',
    shortestPathTitle: '使用矩阵幂计算最短距离',
    piUpperBoundTitle: '通过可视化证明来找出π的上限',
    rotateTitle: '序列旋转算法',
    gcdComparisonTitle: 'GCD算法性能对比',
    rsaTitle: 'RSA公钥密码系统',
    description: '一种使用倍增和加法的古代乘法方法',
    sieveDescription: '一种用于查找给定范围内所有素数的古代算法',
    primeCountingDescription: 'π(n)及其近似n/ln(n)的可视化',
    palindromicPrimesDescription: '查找不同进制下的回文素数',
    gcmDescription: '使用欧几里得算法计算两个数的最大公约数(GCM/GCD)',
    primeCheckerDescription: '判断一个数是否为素数，如果不是则显示其因数分解',
    fibonacciDescription: '使用最初级的递归算法计算斐波那契数，并统计加法次数',
    fastFibonacciDescription: '通过计算矩阵幂次来计算第n个斐波那契数',
    shortestPathDescription: '在热带半环上使用矩阵幂算法计算有向图中的最短路径',
    piUpperBoundDescription: '通过在圆中内接正多边形来找出π的一个上限',
    rotateDescription: '演示如何通过交换两个子序列来实现旋转',
    rotateExplanation: '旋转等同于将整个区域分解成两个子区域，然后交换这两个子区域。例如，将序列[0,1,2,3,4,5,6]旋转5步相当于交换[0,1]和[2,3,4,5,6]，得到[2,3,4,5,6,0,1]。',
    gcdComparisonDescription: '对比斯坦因算法和欧几里得算法计算GCD的性能',
    rsaDescription: '演示RSA加密和解密的步骤',
    range: '区间',
    calculate: '计算',
    reset: '重置',
    running: '正在进行性能测试...',
    results: '结果',
    steinAlgorithm: '斯坦因算法',
    euclideanAlgorithm: '欧几里得算法',
    totalTime: '总耗时',
    milliseconds: '毫秒',
    testSize: '9万对随机数',
    complete: '已完成',
    language: 'English',
    firstNumber: '第一个数',
    secondNumber: '第二个数',
    required: '(必填)',
    inputRequired: '请输入两个数',
    steps: '步数',
    powers: '2的幂',
    doubling: '倍增',
    selected: '选中',
    result: '结果',
    maxNumber: '最大数',
    base: '进制',
    sieveInputDescription: '输入一个数，将找出这个范围内的所有素数',
    sieveInputRequired: '请输入一个2到9999之间的数',
    iteration: '下一步',
    generate: '生成',
    allPrimesFound: '所有素数已找到！绿色背景的数字就是素数。',
    recursiveStep: '下一步',
    startCalculation: '开始计算',
    currentValues: '当前值',
    aValue: 'a = ',
    bValue: 'b = ',
    remainderValue: '余数 = ',
    gcmResult: '最大公约数 = ',
    check: '检查',
    enterNumber: '输入一个数',
    numberPlaceholder: '输入一个数进行检查',
    isPrime: '是素数！',
    isNotPrime: '不是素数。',
    isMersennePrime: '是梅森素数！(2^{0} - 1)',
    mersenneLink: '访问GIMPS（伟大的互联网梅森素数搜索）',
    inputTooLarge: '输入太大。请输入一个较小的数。',
    fastFibonacciInput: '输入一个数（0-5000）',
    fastFibonacciResult: '第n个斐波那契数是：',
    fastFibonacciOperations: '操作次数统计',
    additions: '加法次数：',
    subtractions: '减法次数：',
    multiplications: '乘法次数：',
    fastFibonacciTooLarge: '请输入一个0到5000之间的数',
    powerStep: '矩阵的{0}次幂',
    initialMatrix: '初始邻接矩阵',
    nextPower: '下一次幂',
    calculationComplete: '计算完成！矩阵显示了所有节点对之间的最短距离。',
    shortestPathExplanation: '矩阵显示了节点之间的最短路径距离。∞表示这两个节点之间没有路径。',
    fibonacciInput: '输入一个数（0-40）',
    fibonacciResult: '第{n}个斐波那契数是：',
    additionCount: '执行的加法次数：',
    fibonacciExplanation: '最初级的递归算法会执行大量重复计算，导致加法次数呈指数增长。这就是为什么我们将输入限制在40以内，以防止计算时间过长。',
    fibonacciTimeComplexity: '时间复杂度：O(φⁿ)，其中φ≈1.618是黄金分割比',
    generateKeys: '生成密钥对',
    keyDetails: '密钥详情',
    publicExponent: '公钥指数',
    privateExponent: '私钥指数',
    rsaKeysNote: '注意：为了演示目的，我们使用较小的素数。在实际应用中，使用的是更大的素数（2048位以上）。',
    messageToEncrypt: '要加密的消息',
    enterMessage: '在此输入您的消息',
    encrypt: '加密',
    decrypt: '解密',
    encryptedMessage: '加密后的消息',
    decryptedMessage: '解密后的消息',
    publicKey: '公钥 (e, n)',
    privateKey: '私钥 (d, n)',
    publicKeyFormat: '公钥格式：(e, n)',
    privateKeyFormat: '私钥格式：(d, n)',
    rsaSteps: 'RSA步骤',
    rsaStep1: '1. 密钥生成',
    rsaStep2: '2. 加密',
    rsaStep3: '3. 解密',
    rsaPrimes: '随机素数',
    rsaModulus: '模数',
    rsaTotient: '欧拉函数值',
    rsaEncryptionFormula: '加密公式',
    rsaDecryptionFormula: '解密公式',
    rsaFormulaExplanation: '对消息中的每个字节m：',
    rsaEncryptionFormulaDetail: 'c = m^e mod n',
    rsaDecryptionFormulaDetail: 'm = c^d mod n',
    rsaDataFlow: '数据流',
    rsaOriginalBytes: '原始字节',
    rsaEncryptedValues: '加密值',
    rsaDecryptedBytes: '解密字节',
    rsaShowSteps: '显示步骤',
    rsaHideSteps: '隐藏步骤',
    rsaStep1Explanation: '选择两个随机素数p和q，它们的乘积n作为模数。计算欧拉函数值φ(n) = (p-1)(q-1)。',
    rsaStep2Explanation: '将消息转换为字节，使用公钥(e, n)加密每个字节。',
    rsaStep3Explanation: '使用私钥(d, n)解密每个加密值，恢复原始字节。'
  }
};