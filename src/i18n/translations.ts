export const translations = {
  en: {
    visualizations: 'Algorithm Visualizations',
    contents: 'Contents',
    egyptianMultiplication: 'Section 2.1 - Egyptian Multiplication (Russian Multiplication)', 
    sieveOfEratosthenes: 'Section 3.2-3.3 - Sieve of Eratosthenes',
    primeCounting: 'Exercise 3.3 - Prime Counting Function',
    palindromicPrimes: 'Exercise 3.4 - Palindromic Primes',
    euclideanGcm: 'Section 4.2 - Euclidean Algorithm (GCM/GCD)',
    primeChecker: 'Section 5.1 - Prime Number Checker',
    fibonacci: 'Exercise 7.1 - How Many Additions Does the Basic Fibonacci Algorithm Need?',
    fastFibonacci: 'Section 7.7 - Calculate nth Fibonacci Number Using Power Algorithm (Time Complexity: O(log n))',
    shortestPath: 'Section 8.6 - Finding Shortest Distance Between Any Two Nodes in a Directed Graph',
    backToHome: 'Back to Home',
    title: 'Egyptian Multiplication (Russian Multiplication)',
    sieveTitle: 'Sieve of Eratosthenes',
    primeCountingTitle: 'Prime Counting Function',
    palindromicPrimesTitle: 'Palindromic Primes',
    gcmTitle: 'Euclidean Algorithm (GCM/GCD)',
    primeCheckerTitle: 'Prime Number Checker',
    fibonacciTitle: 'Basic Fibonacci Algorithm',
    fastFibonacciTitle: 'Fast Fibonacci Calculator',
    shortestPathTitle: 'Finding Shortest Distance Using Matrix Power',
    description: 'An ancient method of multiplication using doubling and addition',
    sieveDescription: 'An ancient algorithm for finding all prime numbers up to a given limit',
    primeCountingDescription: 'Visualization of π(n) and its approximation by n/ln(n)',
    palindromicPrimesDescription: 'Find palindromic prime numbers in different bases',
    gcmDescription: 'Calculate the Greatest Common Measure (GCM/GCD) of two numbers using the Euclidean algorithm',
    primeCheckerDescription: 'Check if a number is prime and get its prime factorization',
    fibonacciDescription: 'Calculate Fibonacci numbers and count additions using the basic recursive algorithm',
    fastFibonacciDescription: 'Calculate Fibonacci numbers using matrix exponentiation',
    shortestPathDescription: 'Find shortest paths in a directed graph using matrix power algorithm in the tropical semiring',
    multiply: 'Multiply',
    firstNumber: 'First Number',
    secondNumber: 'Second Number',
    calculate: 'Calculate',
    steps: 'Steps',
    result: 'Result',
    generate: 'Generate',
    maxNumber: 'Maximum Number',
    base: 'Base',
    primes: 'Prime Numbers',
    nonPrimes: 'Non-Prime Numbers',
    iteration: 'Iteration',
    allPrimesFound: 'All prime numbers (with green background) have been found!',
    doubling: 'Doubling',
    powers: 'Powers of Two',
    selected: 'Selected',
    finalSum: 'Final Sum',
    language: '中文',
    reset: 'Reset',
    baseError: 'Base must be at least 2',
    maxNumberError: 'Maximum number must be at least 2',
    recursiveStep: 'Recursive Step',
    gcmResult: 'The Greatest Common Measure (GCM/GCD) is: ',
    currentValues: 'Current Values',
    aValue: 'a = ',
    bValue: 'b = ',
    remainderValue: 'remainder = ',
    invalidInput: 'Please enter two positive numbers',
    enterNumber: 'Enter a number',
    numberPlaceholder: 'Enter a number',
    check: 'Check',
    isPrime: 'is prime!',
    isMersennePrime: 'is a Mersenne prime! (2^{0} - 1)',
    isNotPrime: 'is not prime. Prime factorization:',
    mersenneLink: 'Known Mersenne Primes (as of 2025)',
    fibonacciInput: 'Enter n (0-40)',
    fibonacciResult: 'Fibonacci number:',
    additionCount: 'Number of additions performed:',
    fibonacciCode: 'Basic recursive algorithm:',
    inputTooLarge: 'Input must be between 0 and 40',
    fastFibonacciInput: 'Enter n (0-5000)',
    fastFibonacciResult: 'The nth Fibonacci number is:',
    fastFibonacciTooLarge: 'Input must be between 0 and 5000',
    fastFibonacciOperations: 'Operation counts:',
    additions: 'Additions:',
    subtractions: 'Subtractions:',
    multiplications: 'Multiplications:',
    timeComplexityTitle: 'Why limit n to 40?',
    timeComplexityExplanation: 'This basic recursive algorithm has a time complexity of O(2ⁿ). The number of recursive calls grows exponentially with n. However, as shown in Section 7.7, simple optimizations can reduce the time complexity to O(n), and with further optimization (using the power algorithm) even to O(log n).',
    startCalculation: 'Start Calculation',
    nextPower: 'Next Power',
    initialMatrix: 'Initial Distance Matrix',
    powerStep: 'Matrix Power {0}',
    calculationComplete: 'Calculation complete! The final matrix shows the shortest path between any two nodes.'
  },
  zh: {
    visualizations: '算法可视化',
    contents: '目录',
    egyptianMultiplication: '2.1节 - 埃及乘法(俄式乘法)', 
    sieveOfEratosthenes: '3.2节-3.3节 - 埃拉托色尼筛法',
    primeCounting: '习题3.3 - 素数计数函数 (计算较慢，请耐心等待)',
    palindromicPrimes: '习题3.4 - 回文素数',
    euclideanGcm: '4.2节 - 欧几里得算法(GCM/GCD)',
    primeChecker: '5.1节 - 判断一个数是否为素数',
    fibonacci: '习题7.1 - 最初级的斐波那契数列算法需要执行多少次加法',
    fastFibonacci: '7.7节 - 使用幂算法计算第n个斐波那契数（时间复杂度:O(log⁡n)）',
    shortestPath: '8.6节 - 找出有向图中任意两个节点之间的最短距离',
    backToHome: '返回主页',
    title: '埃及乘法(俄式乘法)',
    sieveTitle: '埃拉托色尼筛法',
    primeCountingTitle: '素数计数函数',
    palindromicPrimesTitle: '回文素数',
    gcmTitle: '欧几里得算法(GCM/GCD)',
    primeCheckerTitle: '素数判定',
    fibonacciTitle: '最初级的斐波那契数列算法',
    fastFibonacciTitle: '快速斐波那契数计算器',
    shortestPathTitle: '使用矩阵幂计算最短距离',
    description: '一种使用倍增和加法的古代乘法方法',
    sieveDescription: '一种用于查找给定范围内所有素数的古代算法',
    primeCountingDescription: 'π(n)及其近似n/ln(n)的可视化',
    palindromicPrimesDescription: '查找不同进制下的回文素数',
    gcmDescription: '使用欧几里得算法计算两个数的最大公约数(GCM/GCD)',
    primeCheckerDescription: '判断一个数是否为素数，如果不是则显示其因数分解',
    fibonacciDescription: '使用最初级的递归算法计算斐波那契数，并统计加法次数',
    fastFibonacciDescription: '通过计算矩阵幂次来计算第n个斐波那契数',
    shortestPathDescription: '在热带半环上使用矩阵幂算法计算有向图中的最短路径',
    multiply: '相乘',
    firstNumber: '第一个数',
    secondNumber: '第二个数',
    calculate: '计算',
    steps: '步骤',
    result: '结果',
    generate: '生成',
    maxNumber: '最大数',
    base: '进制',
    primes: '素数',
    nonPrimes: '非素数',
    iteration: '迭代',
    allPrimesFound: '已找出所有素数(绿底的那些)！',
    doubling: '倍增',
    powers: '2的幂',
    selected: '选中',
    finalSum: '最终和',
    language: 'English',
    reset: '重置',
    baseError: '至少为2进制',
    maxNumberError: '最大数至少为2',
    recursiveStep: '递归',
    gcmResult: '最大公约数(GCM/GCD)是：',
    currentValues: '当前值',
    aValue: 'a = ',
    bValue: 'b = ',
    remainderValue: '余数 = ',
    invalidInput: '请输入两个正数',
    enterNumber: '输入一个数',
    numberPlaceholder: '输入一个数',
    check: '判定',
    isPrime: '是素数！',
    isMersennePrime: '是梅森素数！(2^{0} - 1)',
    isNotPrime: '不是素数。因数分解为：',
    mersenneLink: '目前已知的梅森素数(截止2025年)',
    fibonacciInput: '输入n (0-40)',
    fibonacciResult: '斐波那契数：',
    additionCount: '执行加法次数：',
    fibonacciCode: '最初级的递归算法：',
    inputTooLarge: '输入必须在0到40之间',
    fastFibonacciInput: '输入n (0-5000)',
    fastFibonacciResult: '第n个斐波那契数是：',
    fastFibonacciTooLarge: '输入必须在0到5000之间',
    fastFibonacciOperations: '运算次数统计：',
    additions: '加法次数：',
    subtractions: '减法次数：',
    multiplications: '乘法次数：',
    timeComplexityTitle: '为什么要限制n不能大于40？',
    timeComplexityExplanation: '这个过于初级的算法的时间复杂度为O(2ⁿ)。当n较大时，递归调用次数会急剧增加。但是，如7.7节所述，进行简单的调优，即可将时间复杂度降低至O(n)。更进一步调优，甚至能降低至O(log⁡n)。',
    startCalculation: '开始计算',
    nextPower: '下一个幂',
    initialMatrix: '初始距离矩阵',
    powerStep: '矩阵的{0}次幂',
    calculationComplete: '计算完成！最终矩阵显示了任意两个节点之间的最短路径。'
  }
};