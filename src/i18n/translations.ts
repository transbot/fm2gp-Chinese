export const translations = {
  en: {
    visualizations: 'Algorithm Visualizations',
    contents: 'Contents',
    egyptianMultiplication: 'Section 2.1 - Egyptian Multiplication (Russian Multiplication)', 
    sieveOfEratosthenes: 'Section 3.2-3.3 - Sieve of Eratosthenes',
    primeCounting: 'Exercise 3.3 - Prime Counting Function',
    palindromicPrimes: 'Exercise 3.4 - Palindromic Primes',
    euclideanGcm: 'Section 4.2 - Euclidean Algorithm (GCM/GCD)',
    primeChecker: 'Section 5.1 - Prime Number Checker',
    fibonacci: 'Exercise 7.1 - How Many Additions Does the Basic Fibonacci Algorithm Need?',
    fastFibonacci: 'Section 7.7 - Calculate nth Fibonacci Number Using Power Algorithm (Time Complexity: O(log n))',
    shortestPath: 'Section 8.6 - Finding Shortest Distance Between Any Two Nodes in a Directed Graph',
    piUpperBound: 'Exercise 9.2 - Finding an Upper Bound for π Through Visual Proof',
    rotateAlgorithm: 'Section 11.3 - Demonstration of Sequence Rotation Algorithm',
    backToHome: 'Back to Home',
    title: 'Egyptian Multiplication (Russian Multiplication)',
    sieveTitle: 'Sieve of Eratosthenes',
    primeCountingTitle: 'Prime Counting Function',
    palindromicPrimesTitle: 'Palindromic Primes',
    gcmTitle: 'Euclidean Algorithm (GCM/GCD)',
    primeCheckerTitle: 'Prime Number Checker',
    fibonacciTitle: 'Basic Fibonacci Algorithm',
    fastFibonacciTitle: 'Fast Fibonacci Calculator',
    shortestPathTitle: 'Finding Shortest Distance Using Matrix Power',
    piUpperBoundTitle: 'Visual Proof of π\'s Upper Bound',
    rotateTitle: 'Sequence Rotation Algorithm',
    description: 'An ancient method of multiplication using doubling and addition',
    sieveDescription: 'An ancient algorithm for finding all prime numbers up to a given limit',
    primeCountingDescription: 'Visualization of π(n) and its approximation by n/ln(n)',
    palindromicPrimesDescription: 'Find palindromic prime numbers in different bases',
    gcmDescription: 'Calculate the Greatest Common Measure (GCM/GCD) of two numbers using the Euclidean algorithm',
    primeCheckerDescription: 'Check if a number is prime and get its prime factorization',
    fibonacciDescription: 'Calculate Fibonacci numbers and count additions using the basic recursive algorithm',
    fastFibonacciDescription: 'Calculate Fibonacci numbers using matrix exponentiation',
    shortestPathDescription: 'Find shortest paths in a directed graph using matrix power algorithm in the tropical semiring',
    piUpperBoundDescription: 'Visualize how inscribed regular polygons can help us find an upper bound for π',
    rotateDescription: 'Visualize how rotation can be implemented by swapping two subsequences',
    rotateExplanation: 'Rotation is equivalent to decomposing the entire range into two subranges and then swapping them. For example, rotating [0,1,2,3,4,5,6] by 5 steps is equivalent to swapping [0,1] with [2,3,4,5,6], resulting in [2,3,4,5,6,0,1].',
    steps: 'Steps to rotate',
    rotate: 'Rotate',
    reset: 'Reset',
    animate: 'Animate',
    pause: 'Pause',
    resume: 'Resume',
    initialSequence: 'Initial Sequence',
    rotatedSequence: 'Rotated Sequence',
    subintervalSwap: 'Subrange Swap',
    firstSubinterval: 'First Subrange [f,m)',
    secondSubinterval: 'Second Subrange [m,l)',
    multiply: 'Multiply',
    firstNumber: 'First Number',
    secondNumber: 'Second Number',
    calculate: 'Calculate',
    result: 'Result',
    generate: 'Generate',
    maxNumber: 'Maximum Number',
    base: 'Base',
    primes: 'Prime Numbers',
    nonPrimes: 'Non-Prime Numbers',
    iteration: 'Iteration',
    allPrimesFound: 'All prime numbers (with green background) have been found!',
    doubling: 'Doubling',
    powers: 'Powers of Two',
    selected: 'Selected',
    finalSum: 'Final Sum',
    language: '中文'
  },
  zh: {
    visualizations: '算法可视化',
    contents: '目录',
    egyptianMultiplication: '2.1节 - 埃及乘法(俄式乘法)', 
    sieveOfEratosthenes: '3.2节-3.3节 - 埃拉托色尼筛法',
    primeCounting: '习题3.3 - 素数计数函数 (计算较慢，请耐心等待)',
    palindromicPrimes: '习题3.4 - 回文素数',
    euclideanGcm: '4.2节 - 欧几里得算法(GCM/GCD)',
    primeChecker: '5.1节 - 判断一个数是否为素数',
    fibonacci: '习题7.1 - 最初级的斐波那契数列算法需要执行多少次加法',
    fastFibonacci: '7.7节 - 使用幂算法计算第n个斐波那契数（时间复杂度:O(log⁡n)）',
    shortestPath: '8.6节 - 找出有向图中任意两个节点之间的最短距离',
    piUpperBound: '习题9.2 - 通过可视化证明来找出π的一个上限',
    rotateAlgorithm: '11.3节 - 演示序列的"旋转"算法',
    backToHome: '返回主页',
    title: '埃及乘法(俄式乘法)',
    sieveTitle: '埃拉托色尼筛法',
    primeCountingTitle: '素数计数函数',
    palindromicPrimesTitle: '回文素数',
    gcmTitle: '欧几里得算法(GCM/GCD)',
    primeCheckerTitle: '素数判定',
    fibonacciTitle: '最初级的斐波那契数列算法',
    fastFibonacciTitle: '快速斐波那契数计算器',
    shortestPathTitle: '使用矩阵幂计算最短距离',
    piUpperBoundTitle: '通过可视化证明来找出π的上限',
    rotateTitle: '序列旋转算法',
    description: '一种使用倍增和加法的古代乘法方法',
    sieveDescription: '一种用于查找给定范围内所有素数的古代算法',
    primeCountingDescription: 'π(n)及其近似n/ln(n)的可视化',
    palindromicPrimesDescription: '查找不同进制下的回文素数',
    gcmDescription: '使用欧几里得算法计算两个数的最大公约数(GCM/GCD)',
    primeCheckerDescription: '判断一个数是否为素数，如果不是则显示其因数分解',
    fibonacciDescription: '使用最初级的递归算法计算斐波那契数，并统计加法次数',
    fastFibonacciDescription: '通过计算矩阵幂次来计算第n个斐波那契数',
    shortestPathDescription: '在热带半环上使用矩阵幂算法计算有向图中的最短路径',
    piUpperBoundDescription: '通过在圆中内接正多边形来找出π的一个上限',
    rotateDescription: '演示如何通过交换两个子序列来实现旋转',
    rotateExplanation: '旋转等同于将整个区域分解成两个子区域，然后交换这两个子区域。例如，将序列[0,1,2,3,4,5,6]旋转5步相当于交换[0,1]和[2,3,4,5,6]，得到[2,3,4,5,6,0,1]。',
    steps: '旋转步数',
    rotate: '旋转',
    reset: '重置',
    animate: '动画演示',
    pause: '暂停',
    resume: '继续',
    initialSequence: '初始序列',
    rotatedSequence: '旋转后的序列',
    subintervalSwap: '子区域交换',
    firstSubinterval: '第一个子区域 [f,m)',
    secondSubinterval: '第二个子区域 [m,l)',
    multiply: '相乘',
    firstNumber: '第一个数',
    secondNumber: '第二个数',
    calculate: '计算',
    result: '结果',
    generate: '生成',
    maxNumber: '最大数',
    base: '进制',
    primes: '素数',
    nonPrimes: '非素数',
    iteration: '迭代',
    allPrimesFound: '已找出所有素数(绿底的那些)！',
    doubling: '倍增',
    powers: '2的幂',
    selected: '选中',
    finalSum: '最终和',
    language: 'English'
  }
};